/**
 * Forecast API Endpoints
 *
 * Provides ML-based 7-day price forecasting for AI API pricing.
 * Unique feature: AGORA becomes the only oracle with predictive pricing intelligence.
 *
 * Endpoints:
 * - GET /v1/forecast/:skill - Get 7-day price forecast for a skill
 * - GET /v1/forecast/:skill/accuracy - Get model accuracy metrics
 * - POST /v1/forecast/generate - Trigger forecast regeneration (admin)
 */

import express from 'express';
import { getAll, getOne } from '../db/database.js';
import { generateForecast, evaluateModelAccuracy } from '../forecast/model.js';
import { generateAllForecasts } from '../forecast/scheduler.js';
import logger from '../logger.js';

const router = express.Router();

/**
 * GET /v1/forecast/status
 * Returns forecast system status
 *
 * Shows: How many skills have forecasts, last generation time, total forecasts
 * NOTE: This MUST come before /:skill route to avoid "status" being treated as a skill
 */
router.get('/status', async (req, res) => {
  try {
    const stats = await getAll(
      `SELECT
        COUNT(DISTINCT skill) as totalSkills,
        COUNT(*) as totalForecasts,
        MAX(generated_at) as lastGenerated
      FROM price_forecasts`
    );

    const recentForecasts = await getAll(
      `SELECT skill, COUNT(*) as count
      FROM price_forecasts
      WHERE forecast_date >= DATE('now')
      GROUP BY skill
      ORDER BY count DESC
      LIMIT 10`
    );

    return res.json({
      success: true,
      data: {
        totalSkills: stats[0]?.totalSkills || 0,
        totalForecasts: stats[0]?.totalForecasts || 0,
        lastGenerated: stats[0]?.lastGenerated,
        recentForecasts: recentForecasts.map(f => ({
          skill: f.skill,
          forecastCount: f.count
        }))
      },
      meta: {
        timestamp: new Date().toISOString(),
        apiVersion: '0.4.0'
      }
    });

  } catch (error) {
    logger.error(`Forecast status API error: ${error.message}`);
    return res.status(500).json({
      success: false,
      error: 'Internal server error',
      code: 500
    });
  }
});

/**
 * GET /v1/forecast/:skill
 * Returns 7-day price forecast for a given skill
 *
 * Response includes:
 * - Current price (from rates table)
 * - 7-day forecast (date, predictedPrice, confidence)
 * - Trend (increasing/stable/decreasing)
 * - Recommendation (buy now / wait / current optimal)
 * - Model metadata (version, accuracy, generated timestamp)
 */
router.get('/:skill', async (req, res) => {
  try {
    const { skill } = req.params;

    // Validate skill parameter
    if (!skill || skill.trim() === '') {
      return res.status(400).json({
        success: false,
        error: 'Invalid skill parameter',
        code: 400
      });
    }

    // Query forecasts from database (generated by daily scheduler)
    const forecasts = await getAll(
      `SELECT
        forecast_date as date,
        predicted_price as predictedPrice,
        confidence,
        model_version as modelVersion,
        generated_at as generatedAt
      FROM price_forecasts
      WHERE skill = ?
        AND forecast_date >= DATE('now')
      ORDER BY forecast_date ASC
      LIMIT 7`,
      [skill]
    );

    // If no forecasts available, return 503 (service unavailable - check back later)
    if (!forecasts || forecasts.length === 0) {
      logger.warn(`Forecast not available for skill: ${skill}`);
      return res.status(503).json({
        success: false,
        error: 'Forecast not available yet (check back in 24h)',
        code: 503,
        meta: {
          skill,
          message: 'Forecasts are generated daily at 2 AM UTC. Try again tomorrow.'
        }
      });
    }

    // Get current price from rates table (average across all providers)
    const currentPriceResult = await getOne(
      `SELECT AVG(r.price) as currentPrice
      FROM rates r
      JOIN services s ON r.service_id = s.id
      WHERE s.category || COALESCE('/' || s.subcategory, '') = ?
        OR s.category = ?`,
      [skill, skill.split('/')[0]]
    );

    const currentPrice = currentPriceResult?.currentPrice || forecasts[0].predictedPrice;

    // Calculate trend (compare first vs last forecast)
    const firstPrice = forecasts[0].predictedPrice;
    const lastPrice = forecasts[forecasts.length - 1].predictedPrice;
    const priceChange = ((lastPrice - firstPrice) / firstPrice) * 100;

    let trend, recommendation;

    if (priceChange < -5) {
      trend = 'decreasing';
      recommendation = `Wait 3 days for optimal price (~$${forecasts[2]?.predictedPrice.toFixed(4)})`;
    } else if (priceChange > 5) {
      trend = 'increasing';
      recommendation = 'Buy now before price increases';
    } else {
      trend = 'stable';
      recommendation = 'Current price is optimal';
    }

    // Extract metadata from first forecast
    const modelVersion = forecasts[0].modelVersion || 'exponential_smoothing_v1';
    const generatedAt = forecasts[0].generatedAt;

    // Calculate average confidence
    const avgConfidence = forecasts.reduce((sum, f) => sum + f.confidence, 0) / forecasts.length;

    // Return forecast data
    return res.json({
      success: true,
      data: {
        skill,
        currentPrice: parseFloat(currentPrice.toFixed(4)),
        forecast: forecasts.map(f => ({
          date: f.date,
          predictedPrice: parseFloat(f.predictedPrice.toFixed(4)),
          confidence: parseFloat(f.confidence.toFixed(3))
        })),
        trend,
        trendStrength: parseFloat(priceChange.toFixed(2)), // % change
        recommendation,
        meta: {
          modelVersion,
          generatedAt,
          avgConfidence: parseFloat(avgConfidence.toFixed(3)),
          forecastDays: forecasts.length
        }
      },
      meta: {
        timestamp: new Date().toISOString(),
        apiVersion: '0.4.0'
      }
    });

  } catch (error) {
    logger.error(`Forecast API error: ${error.message}`);
    return res.status(500).json({
      success: false,
      error: 'Internal server error',
      code: 500
    });
  }
});

/**
 * GET /v1/forecast/:skill/accuracy
 * Returns model accuracy metrics for a given skill
 *
 * Uses backtesting: train on 80% of data, test on 20%
 * Metrics: MAE (Mean Absolute Error), RMSE, Accuracy percentage
 *
 * Requires: 60+ days of historical data for meaningful results
 */
router.get('/:skill/accuracy', async (req, res) => {
  try {
    const { skill } = req.params;

    // Validate skill parameter
    if (!skill || skill.trim() === '') {
      return res.status(400).json({
        success: false,
        error: 'Invalid skill parameter',
        code: 400
      });
    }

    // Evaluate model accuracy (backtesting)
    const accuracy = await evaluateModelAccuracy(skill);

    // If no accuracy data (insufficient historical data), return 404
    if (!accuracy || accuracy.mae === null) {
      return res.status(404).json({
        success: false,
        error: 'Insufficient data for accuracy evaluation (need 60+ days)',
        code: 404,
        meta: {
          skill,
          testDays: accuracy?.testDays || 0
        }
      });
    }

    return res.json({
      success: true,
      data: {
        skill,
        mae: parseFloat(accuracy.mae.toFixed(4)),
        rmse: parseFloat(accuracy.rmse.toFixed(4)),
        accuracy: parseFloat((accuracy.accuracy * 100).toFixed(2)), // convert to percentage
        testDays: accuracy.testDays
      },
      meta: {
        timestamp: new Date().toISOString(),
        apiVersion: '0.4.0',
        message: 'Accuracy calculated using 80/20 train-test split on historical data'
      }
    });

  } catch (error) {
    logger.error(`Forecast accuracy API error: ${error.message}`);
    return res.status(500).json({
      success: false,
      error: 'Internal server error',
      code: 500
    });
  }
});

/**
 * POST /v1/forecast/generate
 * Triggers forecast regeneration for all skills
 *
 * Admin-only endpoint (no auth for now, add later if needed)
 * Use case: Manual trigger after new data ingestion
 *
 * Returns: Number of skills processed and forecasts generated
 */
router.post('/generate', async (req, res) => {
  try {
    logger.info('Manual forecast generation triggered');

    // Call forecast scheduler (generates forecasts for all skills)
    const result = await generateAllForecasts();

    return res.json({
      success: true,
      data: {
        skillsProcessed: result.skills,
        forecastsGenerated: result.forecastsGenerated,
        message: `Generated ${result.forecastsGenerated} forecasts across ${result.skills} skills`
      },
      meta: {
        timestamp: new Date().toISOString(),
        apiVersion: '0.4.0'
      }
    });

  } catch (error) {
    logger.error(`Forecast generation API error: ${error.message}`);
    return res.status(500).json({
      success: false,
      error: 'Forecast generation failed',
      code: 500,
      details: error.message
    });
  }
});

export default router;
